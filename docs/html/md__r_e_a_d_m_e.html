<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rt2_assignment: Research Track 2 - Second Assignment 4482512 Enrico Fiasche&#39; (Robotics Engineering / JEMARO, Unige)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rt2_assignment
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Package for second assignment of Research Track II</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Research Track 2 - Second Assignment 4482512 Enrico Fiasche' (Robotics Engineering / JEMARO, Unige) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
General information</h1>
<p>The assignment requires developing a software architecture for the control of a robot in the environment. The <b>go_to_point</b> node must be modelled as a ROS action server. During the simulation, the user can press "1" to give a random goal to the robot, and then press "0" to stop the robot.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Nodes and program description</h1>
<p>In the assignment there are four different program used to achieve the goal required by the assignment. The program are writtten two in Python and two in C++:</p><ul>
<li>The first one, <b><a class="el" href="go__to__point_8py.html" title="This node drive the robot to the desired position received.">go_to_point.py</a></b>, is an <em>action server</em> used to reach a given goal. This node use a publisher, which publishes the velocity of the robot through the <em>cmd_vel</em> topic, and a subscriber, which checks the position of the robot through the <em>odom</em> topic. If a new goal is set, this node fix the yaw angle in order to be aligned with the goal, then the robot can go straight towards the target point and finally, when the robot is near the desired position, it can fix the final yaw angle in order to have the same orientation of the given goal. During these operations, the node checks continuously if the goal is canceled in order to stop the robot.</li>
<li><p class="startli">The second one, <b>user_interface</b>, is a client used to read the user command and to send it to the <b>state_machine</b> node. This node sends the new command through the service message <em>Command</em> and has an action client, which is connected to <b>go_to_point</b>. It is managed by the Jupyter Notebook, Now the user interface is able of:</p><ul>
<li>starting/stopping the robot "random position" behaviour by using two buttons</li>
<li>setting the linear and angular velocity by using two sliders</li>
<li>controlling the robot movements by using 5 buttons (on for each direction + button stop)</li>
</ul>
<p class="startli">The notebook has a section for displaying some graphical information, in particular:</p><ul>
<li>a line plot for compare the cmd_vel and actual velocity (odom)</li>
<li>a bar plot displaying the number of reached targets and canceled targets</li>
<li>a hist plot showing the time required to reach targets</li>
<li>an xy graph showing the robot's position and orientation. If the user presses "1",</li>
</ul>
</li>
<li>The third one, <b><a class="el" href="position__service_8cpp.html" title="It is a simple server that generates three random number.">position_service.cpp</a></b>, is a simple server that generates three random number. This node uses the service message <em>RandomPosition</em> which has as request the minimum and maximum value allowed for the x and y position, and it has as response the three coordinates of the random goal (x,y posiion and the orientation theta).</li>
<li>The last one, <b><a class="el" href="state__machine_8cpp.html" title="Main node that manages the whole simulation.">state_machine.cpp</a></b>, is a node used to communicate with all the other nodes. This one has a simple client, which is connected to the <b><a class="el" href="position__service_8cpp.html" title="It is a simple server that generates three random number.">position_service.cpp</a></b> in order to receive the next goal, a server, which receives the request done by the user through the <b>user_interface</b> node, and an action client, which is used to send new goals and to check if a target is reached. Before start searching a new goal the state machine checks if there is a <em>Command</em> request from a client, then if the user command is "_start_" the node make a request to <b><a class="el" href="position__service_8cpp.html" title="It is a simple server that generates three random number.">position_service.cpp</a></b> receiving a goal between -5.0 and 5.0, regarding x and y position, and the theta orientation, then the state machine sends this goal to the server using the action client and waits for a result, which could be a "success" in case of goal reached and a "failure" in case of goal canceled.</li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
Launch files</h2>
<p>In the folder <em>launch</em> there are two different launch files:</p><ul>
<li>The first one, <b>gazeboSim.launch</b>, used to launch the Gazebo environment and to run the four nodes together.</li>
<li>The second one, <b>vrepSim.launch</b>, used to launch only the four nodes together.</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
How to run the code</h1>
<h2><a class="anchor" id="autotoc_md5"></a>
Simulation with Gazebo</h2>
<p>The package contains the nodes and the simulation environment for controlling a mobile robot in the Gazebo simulation environment. Before launching the node, please source your ROS workspace, just writing this on the terminal: </p><div class="fragment"><div class="line">source path_your_workspace/devel/setup.bash</div>
</div><!-- fragment --><p>To launch the nodes, please run: </p><div class="fragment"><div class="line">roslaunch rt2_assignment1 gazeboSim.launch</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Simulation with VRep</h2>
<p>You can also run the simulation using <b>VRep</b>. You need three different terminal to run this simulation. In the first one you need to source your ROS workspace (or sourcing directly ros.sh) and run roscore: </p><div class="fragment"><div class="line">source path_your_workspace/devel/setup.bash</div>
<div class="line">roscore</div>
</div><!-- fragment --><p>In the second terminal you need to launch <b>CoppeliaSim</b>: </p><div class="fragment"><div class="line">source path_your_workspace/devel/setup.bash</div>
<div class="line">cd path_CoppeliaSim/</div>
<div class="line">./coppeliaSim.sh</div>
</div><!-- fragment --><p>When the CoppeliaSim program is running, open the scene "vrepSceneR2D2.ttt" inside the rt2_assignment1 package and start the simulation pressing play. In the last terminal launch the nodes: </p><div class="fragment"><div class="line">source path_your_workspace/devel/setup.bash</div>
<div class="line">roslaunch rt2_assignment1 vrepSim.launch</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
