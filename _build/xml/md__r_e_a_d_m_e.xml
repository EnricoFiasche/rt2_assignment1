<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="md__r_e_a_d_m_e" kind="page">
    <compoundname>md_README</compoundname>
    <title>Research Track 2 - First Assignment 4482512 Enrico Fiasche&apos; (Robotics Engineering / JEMARO, Unige)</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md1">
<title>General information</title>
<para>The assignment requires developing a software architecture for the control of a robot in the environment. The <bold><ref refid="namespacego__to__point" kindref="compound">go_to_point</ref></bold> node must be modelled as a ROS action server. During the simulation, the user can press &quot;1&quot; to give a random goal to the robot, and then press &quot;0&quot; to stop the robot.</para>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md2">
<title>Nodes and program description</title>
<para>In the assignment there are four different program used to achieve the goal required by the assignment. The program are writtten two in Python and two in C++:<itemizedlist>
<listitem><para>The first one, <bold>go_to_point.py</bold>, is an <emphasis>action server</emphasis> used to reach a given goal. This node use a publisher, which publishes the velocity of the robot through the <emphasis>cmd_vel</emphasis> topic, and a subscriber, which checks the position of the robot through the <emphasis>odom</emphasis> topic. If a new goal is set, this node fix the yaw angle in order to be aligned with the goal, then the robot can go straight towards the target point and finally, when the robot is near the desired position, it can fix the final yaw angle in order to have the same orientation of the given goal. During these operations, the node checks continuously if the goal is canceled in order to stop the robot.</para>
</listitem><listitem><para>The second one, <bold>user_interface</bold>, is a client used to read the user command and to send it to the <bold>state_machine</bold> node. This node sends the new command through the service message <emphasis>Command</emphasis> and has an action client, which is connected to <bold><ref refid="namespacego__to__point" kindref="compound">go_to_point</ref></bold>. It is managed by the Jupyter Notebook, Now the user interface is able of:<itemizedlist>
<listitem><para>starting/stopping the robot &quot;random position&quot; behaviour by using two buttons</para>
</listitem><listitem><para>setting the linear and angular velocity by using two sliders</para>
</listitem><listitem><para>controlling the robot movements by using 5 buttons (on for each direction + button stop)</para>
</listitem></itemizedlist>
</para>
<para>The notebook has a section for displaying some graphical information, in particular:<itemizedlist>
<listitem><para>a line plot for compare the cmd_vel and actual velocity (odom)</para>
</listitem><listitem><para>a bar plot displaying the number of reached targets and canceled targets</para>
</listitem><listitem><para>a hist plot showing the time required to reach targets</para>
</listitem><listitem><para>an xy graph showing the robot&apos;s position and orientation. If the user presses &quot;1&quot;,</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para>The third one, <bold><ref refid="position__service_8cpp" kindref="compound">position_service.cpp</ref></bold>, is a simple server that generates three random number. This node uses the service message <emphasis>RandomPosition</emphasis> which has as request the minimum and maximum value allowed for the x and y position, and it has as response the three coordinates of the random goal (x,y posiion and the orientation theta).</para>
</listitem><listitem><para>The last one, <bold><ref refid="state__machine_8cpp" kindref="compound">state_machine.cpp</ref></bold>, is a node used to communicate with all the other nodes. This one has a simple client, which is connected to the <bold><ref refid="position__service_8cpp" kindref="compound">position_service.cpp</ref></bold> in order to receive the next goal, a server, which receives the request done by the user through the <bold>user_interface</bold> node, and an action client, which is used to send new goals and to check if a target is reached. Before start searching a new goal the state machine checks if there is a <emphasis>Command</emphasis> request from a client, then if the user command is &quot;_start_&quot; the node make a request to <bold><ref refid="position__service_8cpp" kindref="compound">position_service.cpp</ref></bold> receiving a goal between -5.0 and 5.0, regarding x and y position, and the theta orientation, then the state machine sends this goal to the server using the action client and waits for a result, which could be a &quot;success&quot; in case of goal reached and a &quot;failure&quot; in case of goal canceled.</para>
</listitem></itemizedlist>
</para>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md3">
<title>Launch files</title>
<para>In the folder <emphasis>launch</emphasis> there are two different launch files:<itemizedlist>
<listitem><para>The first one, <bold>gazeboSim.launch</bold>, used to launch the Gazebo environment and to run the four nodes together.</para>
</listitem><listitem><para>The second one, <bold>vrepSim.launch</bold>, used to launch only the four nodes together.</para>
</listitem></itemizedlist>
</para>
</sect2>
</sect1>
<sect1 id="md__r_e_a_d_m_e_1autotoc_md4">
<title>How to run the code</title>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md5">
<title>Simulation with Gazebo</title>
<para>The package contains the nodes and the simulation environment for controlling a mobile robot in the Gazebo simulation environment. Before launching the node, please source your ROS workspace, just writing this on the terminal: <programlisting><codeline><highlight class="normal">source<sp/>path_your_workspace/devel/setup.bash</highlight></codeline>
</programlisting></para>
<para>To launch the nodes, please run: <programlisting><codeline><highlight class="normal">roslaunch<sp/>rt2_assignment1<sp/>gazeboSim.launch</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md__r_e_a_d_m_e_1autotoc_md6">
<title>Simulation with VRep</title>
<para>You can also run the simulation using <bold>VRep</bold>. You need three different terminal to run this simulation. In the first one you need to source your ROS workspace (or sourcing directly ros.sh) and run roscore: <programlisting><codeline><highlight class="normal">source<sp/>path_your_workspace/devel/setup.bash</highlight></codeline>
<codeline><highlight class="normal">roscore</highlight></codeline>
</programlisting></para>
<para>In the second terminal you need to launch <bold>CoppeliaSim</bold>: <programlisting><codeline><highlight class="normal">source<sp/>path_your_workspace/devel/setup.bash</highlight></codeline>
<codeline><highlight class="normal">cd<sp/>path_CoppeliaSim/</highlight></codeline>
<codeline><highlight class="normal">./coppeliaSim.sh</highlight></codeline>
</programlisting></para>
<para>When the CoppeliaSim program is running, open the scene &quot;vrepSceneR2D2.ttt&quot; inside the rt2_assignment1 package and start the simulation pressing play. In the last terminal launch the nodes: <programlisting><codeline><highlight class="normal">source<sp/>path_your_workspace/devel/setup.bash</highlight></codeline>
<codeline><highlight class="normal">roslaunch<sp/>rt2_assignment1<sp/>vrepSim.launch</highlight></codeline>
</programlisting> </para>
</sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
